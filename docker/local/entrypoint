#!/bin/bash

set -o errexit
set -o pipefail
set -o nounset

# Set default PostgreSQL user if not provided
if [ -z "${POSTGRES_USER}" ]; then
    base_postgres_image_default_user='postgres'
    export POSTGRES_USER="${base_postgres_image_default_user}"
fi

# Function to check if PostgreSQL is ready using psycopg3
postgres_ready() {
uv run - <<EOF
import sys
import asyncpg
import asyncio

async def check_postgres():
    try:
        conn = await asyncpg.connect(
            user="${POSTGRES_USER}",
            password="${POSTGRES_PASSWORD}",
            database="${POSTGRES_DB}",
            host="${POSTGRES_HOST}",
            port="${POSTGRES_PORT}",
        )
        # Test the connection by running a simple query
        await conn.execute("SELECT 1")
        await conn.close()
        return True
    except Exception as e:
        print(f"Error: {e}")
        return False

async def main():
    if await check_postgres():
        sys.exit(0)
    sys.exit(-1)

asyncio.run(main())
EOF
}

# Implement exponential backoff with jitter
max_attempts=10
base_sleep=1
max_sleep=32  # Maximum wait time

attempt=0
cd /app
until postgres_ready; do
  attempt=$((attempt + 1))
  if [ "$attempt" -gt "$max_attempts" ]; then
    >&2 echo "PostgreSQL is still unavailable after $max_attempts attempts. Exiting."
    exit 1
  fi

  # Calculate exponential backoff time with jitter
  sleep_time=$((base_sleep * (2 ** (attempt - 1))))
  sleep_time=$((sleep_time < max_sleep ? sleep_time : max_sleep))
  jitter=$(awk -v min=0 -v max=100 'BEGIN{srand(); print min+rand()*(max-min)}') # Jitter in milliseconds
  jitter=$(bc <<< "scale=2; $jitter / 1000") # Convert to seconds
  sleep_time=$(bc <<< "scale=2; $sleep_time + $jitter")

  >&2 echo "Attempt $attempt: Waiting for PostgreSQL... retrying in $sleep_time seconds."
  sleep "$sleep_time"
done

>&2 echo 'PostgreSQL is available.'

# Execute the provided command
exec "$@"
